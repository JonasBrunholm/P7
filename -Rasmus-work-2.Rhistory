data = plot_data_rect, aes(xmin = date_start, xmax = date_end),
ymin = -Inf, ymax = Inf, alpha = 0.1, inherit.aes = F
)
ggplot(data = u_d$stock, aes(x = date, y = price)) +
geom_line() +
geom_rect(
data = plot_data_rect, aes(xmin = date_start, xmax = date_end),
ymin = -Inf, ymax = Inf, alpha = 0.1, inherit.aes = F
) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month")
View(plot_data_rect)
stock <- ggplot(data = u_d$stock, aes(x = date, y = price)) +
geom_line() +
geom_rect(
data = plot_data_rect, aes(xmin = date_start, xmax = date_end),
ymin = -Inf, ymax = Inf, alpha = 0.1, inherit.aes = F
) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month")
bubble <- ggplot(data = plot_data_combined, aes(x = x, y = value, color = name)) +
geom_line(size = 1) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month") +
theme(legend.position = "bottom")
grid.arrange(stock, bubble, nrow = 2)
View(plot_data_rect)
styler:::style_active_file()
View(stock)
styler:::style_active_file()
plot_GSADF <- function(u, d = NULL, d_t = NULL, p_restrict = 0.95, start_date_tq_get = "2020-01-01") {
plot_data_combined <- combined_count(u = u, d_t = d_t, d = d, p_restrict = p_restrict)
plot_data_rect <- u$result %>%
filter(p_val == max(u$result$p_val)) %>%
mutate(
date_start = ymd(start_date_tq_get) + start_day,
date_end = ymd(start_date_tq_get) + end_day
)
stock <- ggplot(data = u$stock, aes(x = date, y = price)) +
geom_line() +
geom_rect(
data = plot_data_rect, aes(xmin = date_start, xmax = date_end),
ymin = -Inf, ymax = Inf, alpha = 0.1, inherit.aes = F
) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month")
bubble <- ggplot(data = plot_data_combined, aes(x = x, y = value, color = name)) +
geom_line(size = 1) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month") +
theme(legend.position = "bottom")
grid.arrange(stock, bubble, nrow = 2)
}
plot_GSADF(u = u_d)
source("plot_GSADF.R")
source("plot_GSADF.R")
source("plot_GSADF.R")
source("discount.R")
source("p_val_fun.R")
source("GSADF.R")
source("combined_count.R")
source("plot_GSADF.R")
u_d <- GSADF(
min_window = 30, step_length = 1,
window_increase = 1, ticker = "BTC-USD",
date_from = "2020-01-01", date_to = Sys.Date(), drift = F, trend = F
)
source("plot_GSADF.R")
plot_GSADF(u = u_d, image_name = "btc_2020")
plot_GSADF <- function(u, d = NULL, d_t = NULL, p_restrict = 0.95, start_date_tq_get = "2020-01-01",
image_name = NULL, valuta = "USD") {
model_nr <- case_when(is.null(d_t) & is.null(d) ~ 1,
is.null(d_t) ~ 2,
!is.null(d_t) ~ 3)
plot_data_combined <- combined_count(u = u, d_t = d_t, d = d, p_restrict = p_restrict)
plot_data_rect <- u$result %>%
filter(p_val == max(u$result$p_val)) %>%
mutate(
date_start = ymd(start_date_tq_get) + start_day,
date_end = ymd(start_date_tq_get) + end_day
)
stock <- ggplot(data = u$stock, aes(x = date, y = price)) +
geom_line() +
geom_rect(
data = plot_data_rect, aes(xmin = date_start, xmax = date_end),
ymin = -Inf, ymax = Inf, alpha = 0.1, inherit.aes = F
) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month") +
xlab("")
bubble <- ggplot(data = plot_data_combined, aes(x = x, y = value, color = name)) +
geom_line(size = 1) +
scale_x_date(date_labels = "%Y %b", date_breaks = "2 month") +
theme(legend.position = "bottom") +
xlab("") +
ylab(paste("Price in", valuta))
if (model_nr == 1) {
bubble <- bubble + theme(legend.position = "none")
}
if (!is.null(image_name)) {
file_name <- paste("Billeder/", image_name, ".pdf", sep = "")
pdf(file = file_name, height = 4,width = 8)
grid.arrange(stock, bubble, nrow = 2)
dev.off()
cat("image found in ", file_name)
} else {
grid.arrange(stock, bubble, nrow = 2) }
}
source("plot_GSADF.R")
plot_GSADF(u = u_d, image_name = NULL, valuta = "USD")
source("plot_GSADF.R")
plot_GSADF(u = u_d, image_name = NULL, valuta = "USD")
source("plot_GSADF.R")
plot_GSADF(u = u_d, image_name = NULL, valuta = "USD", aktie = "Bitcoin")
source("plot_GSADF.R")
plot_GSADF(u = u_d, image_name = NULL, valuta = "USD", aktie = "Bitcoin")
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(language = "en")
Sys.setlocale("LC_ALL", "English")
library(reshape2)
library(tidyquant)
library(tidyverse)
library(forecast)
library(microbenchmark)
library(aTSA)
library(gridExtra)
library(lubridate)
Ticker_code <- "btc-usd"
Aktie_navn <- "Bitcoin"
valuta_for_aktie <- "USD"
gsadf_u <- GSADF(ticker = Ticker_code,
min_window = 60,
step_length = 1,
window_increase = 1,
date_from = "2020-01-01",
date_to = "2020-12-01",
drift = NULL,
trend = NULL,
risk_free_rate = 0.01)
plot_GSADF(u = gsadf_u,
d = NULL,
d_t = NULL,
p_restrict = 0.95,
start_date_tq_get = "2020-01-01",
image_name = NULL,
valuta = valuta_for_aktie,
aktie = Aktie_navn)
source("DF_distribution.R") # simulate Dickey Fuller distribution
source("discount.R") # discount prices, bruges i GSADF
source("p_val_fun.R") # calculate p values, bruges i GSADF
source("GSADF.R") # Implementation of GSADF
source("combined_count.R") # count number of intervals the days are in, bruges i plot_GSADF
source("plot_GSADF.R") # plot the result
Ticker_code <- "btc-usd"
Aktie_navn <- "Bitcoin"
valuta_for_aktie <- "USD"
gsadf_u <- GSADF(ticker = Ticker_code,
min_window = 60,
step_length = 1,
window_increase = 1,
date_from = "2020-01-01",
date_to = "2020-12-01",
drift = NULL,
trend = NULL,
risk_free_rate = 0.01)
plot_GSADF(u = gsadf_u,
d = NULL,
d_t = NULL,
p_restrict = 0.95,
start_date_tq_get = "2020-01-01",
image_name = NULL,
valuta = valuta_for_aktie,
aktie = Aktie_navn)
source("DF_distribution.R") # simulate Dickey Fuller distribution
source("discount.R") # discount prices, bruges i GSADF
source("p_val_fun.R") # calculate p values, bruges i GSADF
source("GSADF.R") # Implementation of GSADF
source("combined_count.R") # count number of intervals the days are in, bruges i plot_GSADF
source("plot_GSADF.R") # plot the result
Ticker_code <- "btc-usd"
Aktie_navn <- "Bitcoin"
valuta_for_aktie <- "USD"
gsadf_u <- GSADF(ticker = Ticker_code,
min_window = 60,
step_length = 1,
window_increase = 1,
date_from = "2020-01-01",
date_to = "2020-12-01",
drift = NULL,
trend = NULL,
risk_free_rate = 0.01)
plot_GSADF(u = gsadf_u,
d = NULL,
d_t = NULL,
p_restrict = 0.95,
start_date_tq_get = "2020-01-01",
image_name = NULL,
valuta = valuta_for_aktie,
aktie = Aktie_navn)
gsadf_u <- GSADF(ticker = Ticker_code,
min_window = 60,
step_length = 1,
window_increase = 1,
date_from = "2020-01-01",
date_to = "2020-12-01",
drift = NULL,
trend = NULL,
risk_free_rate = 0.01)
source("DF_distribution.R") # simulate Dickey Fuller distribution
source("discount.R") # discount prices, bruges i GSADF
source("p_val_fun.R") # calculate p values, bruges i GSADF
source("GSADF.R") # Implementation of GSADF
source("combined_count.R") # count number of intervals the days are in, bruges i plot_GSADF
source("plot_GSADF.R") # plot the result
Ticker_code <- "btc-usd"
Aktie_navn <- "Bitcoin"
valuta_for_aktie <- "USD"
gsadf_u <- GSADF(ticker = Ticker_code,
min_window = 60,
step_length = 1,
window_increase = 1,
date_from = "2020-01-01",
date_to = "2020-12-01",
drift = F,
trend = F,
risk_free_rate = 0.01)
plot_GSADF(u = gsadf_u,
d = NULL,
d_t = NULL,
p_restrict = 0.95,
start_date_tq_get = "2020-01-01",
image_name = NULL,
valuta = valuta_for_aktie,
aktie = Aktie_navn)
Ticker_code <- "btc-usd"
Aktie_navn <- "Bitcoin"
valuta_for_aktie <- "USD"
date_from <- "2020-01-01"
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(language="en")
library(ggplot2)
library(dplyr)
library(magrittr)
library(doBy)
library(dlm)
library(dlmextra)
data(milkman) # i doBy
# morgen malkning, røde køer, fjerner cowlacts med NA i my eller dfc
milkman <- milkman %>% filter(ampm == 1, race == "RDM") %>%
group_by(cowlact) %>% filter(!(is.na(dfc) | is.na(my))) %>% ungroup()
milkman_lang_cowlact <- milkman %>% group_by(cowlact) %>% summarise(max_dfc = length(my)) %>%
filter(max_dfc >= 250) %>% pull(cowlact) # cowlact med mindst 250 obs.
milkman <- milkman %>% subset(cowlact %in% milkman_lang_cowlact) # vælger kun cowlact med mindst 250 obs.
ggplot(milkman) + geom_line(aes(x=dfc, y=my, color=cowlact))
#deler op i 2 dataset, for 1 kalv og mere end 2 kalve
milk1 <- subset(milkman, lactno==1)
milk2 <- subset(milkman, lactno>=2)
ggplot(milk1) + geom_line(aes(x=dfc, y=my, color=cowlact))
ggplot(milk2) + geom_line(aes(x=dfc, y=my, color=cowlact))
# fokus på en cowlact
ggplot(milkman %>% filter(cowlact=="0297.2")) + geom_line(aes(x = dfc, y = my)) # ko nr. 0297, 2 kalv
# funktionen til at finde m og C
bayes_lm <- function(formula, data, m, C, phi) {
mf <- model.frame(formula, data = data)
X <- model.matrix(mf, data = data)
y <- mf[, 1]
W <- as.matrix(diag(nrow(data)) * phi)
## YOUR CODE GOES HERE
## ...
m_updated <- m + C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% (y - X %*% m)
C_updated <- C - C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% X %*% C
out <- list(
formula = formula, m = m_updated,
sd = sqrt(diag(C_updated)),
C = C_updated, phi = phi, data = data,
## The call=... may not make sense to you, but will
## prove useful later
call = match.call()
)
class(out) <- "bayes_lm"
out
}
data <- tibble(x = seq_along(y),
y = y)
y <- milkman %>% filter(cowlact=="0297.2") %>% pull(my)
x <- seq_along(y)
n <- length(x)
# funktionen til at finde m og C
bayes_lm <- function(formula, data, m, C, phi) {
mf <- model.frame(formula, data = data)
X <- model.matrix(mf, data = data)
y <- mf[, 1]
W <- as.matrix(diag(nrow(data)) * phi)
## YOUR CODE GOES HERE
## ...
m_updated <- m + C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% (y - X %*% m)
C_updated <- C - C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% X %*% C
out <- list(
formula = formula, m = m_updated,
sd = sqrt(diag(C_updated)),
C = C_updated, phi = phi, data = data,
## The call=... may not make sense to you, but will
## prove useful later
call = match.call()
)
class(out) <- "bayes_lm"
out
}
data <- tibble(x = seq_along(y),
y = y)
woods_function <- log(y) ~ 1 + log(x) + x
result_bayes <- bayes_lm(formula = woods_function,
data = data[1:200,],
m = c(3.5,0.1,-1),
C = matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3),
phi = 1)
result_bayes$m
result_bayes <- bayes_lm(formula = woods_function,
data = data[1:200,],
m = c(2,0.1,-0.002),
C = matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3),
phi = 1)
result_bayes$m
prediction_bayes_lm <- exp(result_bayes$m[1] +
result_bayes$m[2] * log(data$x) +
result_bayes$m[3] * data$x)
bayes_lm_plot <- function(sample_size, formula, data, m, C, phi) {
data_sample <- data[1:sample_size,]
result_bayes <- bayes_lm(formula = formula, data = data_sample,m = m,C = C,phi = phi)
prediction_bayes_lm <- exp(result_bayes$m[1] +
result_bayes$m[2] * log(data$x) +
result_bayes$m[3] * data$x)
plot_data <- tibble(t = data$x[-(1:sample_size)], p_my = prediction_bayes_lm[-(1:sample_size)])
ggplot(data = data, aes(x = x)) +
geom_line(data = data, aes(x = x, y = y), color = "black") +
geom_line(data = plot_data, aes(x = t, y = p_my), color = "red")
}
data <- tibble(x = seq_along(y),
y = y)
woods_function <- log(y) ~ 1 + log(x) + x
m <- c(3.5,0.1,-1)
C <- matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3)
phi <- 1
bayes_lm_plot(sample_size = 20, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 50, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 100, formula = woods_function, data = data, m = m,C = C,phi = phi)
m <- c(2,0.1,-0.002)
C <- matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3)
phi <- 1
bayes_lm_plot(sample_size = 20, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 50, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 100, formula = woods_function, data = data, m = m,C = C,phi = phi)
y <- milkman %>% filter(cowlact=="0916.1") %>% pull(my)
x <- seq_along(y)
n <- length(x)
# funktionen til at finde m og C
bayes_lm <- function(formula, data, m, C, phi) {
mf <- model.frame(formula, data = data)
X <- model.matrix(mf, data = data)
y <- mf[, 1]
W <- as.matrix(diag(nrow(data)) * phi)
## YOUR CODE GOES HERE
## ...
m_updated <- m + C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% (y - X %*% m)
C_updated <- C - C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% X %*% C
out <- list(
formula = formula, m = m_updated,
sd = sqrt(diag(C_updated)),
C = C_updated, phi = phi, data = data,
## The call=... may not make sense to you, but will
## prove useful later
call = match.call()
)
class(out) <- "bayes_lm"
out
}
data <- tibble(x = seq_along(y),
y = y)
woods_function <- log(y) ~ 1 + log(x) + x
result_bayes <- bayes_lm(formula = woods_function,
data = data[1:200,],
m = c(2,0.1,-0.002),
C = matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3),
phi = 1)
result_bayes$m
prediction_bayes_lm <- exp(result_bayes$m[1] +
result_bayes$m[2] * log(data$x) +
result_bayes$m[3] * data$x)
bayes_lm_plot <- function(sample_size, formula, data, m, C, phi) {
data_sample <- data[1:sample_size,]
result_bayes <- bayes_lm(formula = formula, data = data_sample,m = m,C = C,phi = phi)
prediction_bayes_lm <- exp(result_bayes$m[1] +
result_bayes$m[2] * log(data$x) +
result_bayes$m[3] * data$x)
plot_data <- tibble(t = data$x[-(1:sample_size)], p_my = prediction_bayes_lm[-(1:sample_size)])
ggplot(data = data, aes(x = x)) +
geom_line(data = data, aes(x = x, y = y), color = "black") +
geom_line(data = plot_data, aes(x = t, y = p_my), color = "red")
}
data <- tibble(x = seq_along(y),
y = y)
woods_function <- log(y) ~ 1 + log(x) + x
m <- c(2,0.1,-0.002)
C <- matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3)
phi <- 1
bayes_lm_plot(sample_size = 20, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 50, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 100, formula = woods_function, data = data, m = m,C = C,phi = phi)
result_bayes$m
result_bayes <- bayes_lm(formula = woods_function,
data = data, #[1:200,],
m = c(2,0.1,-0.002),
C = matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3),
phi = 1)
result_bayes$m
library(ggplot2)
library(dplyr)
library(magrittr)
library(doBy)
library(dlm)
library(dlmextra)
data(milkman) # i doBy
# morgen malkning, røde køer, fjerner cowlacts med NA i my eller dfc
milkman <- milkman %>% filter(ampm == 1, race == "RDM") %>%
group_by(cowlact) %>% filter(!(is.na(dfc) | is.na(my))) %>% ungroup()
milkman_lang_cowlact <- milkman %>% group_by(cowlact) %>% summarise(max_dfc = length(my)) %>%
filter(max_dfc >= 250) %>% pull(cowlact) # cowlact med mindst 250 obs.
milkman <- milkman %>% subset(cowlact %in% milkman_lang_cowlact) # vælger kun cowlact med mindst 250 obs.
ggplot(milkman) + geom_line(aes(x=dfc, y=my, color=cowlact))
#deler op i 2 dataset, for 1 kalv og mere end 2 kalve
milk1 <- subset(milkman, lactno==1)
milk2 <- subset(milkman, lactno>=2)
ggplot(milk1) + geom_line(aes(x=dfc, y=my, color=cowlact))
ggplot(milk2) + geom_line(aes(x=dfc, y=my, color=cowlact))
# fokus på en cowlact
ggplot(milkman %>% filter(cowlact=="0297.2")) + geom_line(aes(x = dfc, y = my)) # ko nr. 0297, 2 kalv
y <- milkman %>% filter(cowlact=="0916.1") %>% pull(my)
x <- seq_along(y)
n <- length(x)
# funktionen til at finde m og C
bayes_lm <- function(formula, data, m, C, phi) {
mf <- model.frame(formula, data = data)
X <- model.matrix(mf, data = data)
y <- mf[, 1]
W <- as.matrix(diag(nrow(data)) * phi)
## YOUR CODE GOES HERE
## ...
m_updated <- m + C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% (y - X %*% m)
C_updated <- C - C %*% t(X) %*% solve(X %*% C %*% t(X) + W) %*% X %*% C
out <- list(
formula = formula, m = m_updated,
sd = sqrt(diag(C_updated)),
C = C_updated, phi = phi, data = data,
## The call=... may not make sense to you, but will
## prove useful later
call = match.call()
)
class(out) <- "bayes_lm"
out
}
data <- tibble(x = seq_along(y),
y = y)
woods_function <- log(y) ~ 1 + log(x) + x
result_bayes <- bayes_lm(formula = woods_function,
data = data, #[1:200,],
m = c(2,0.1,-0.002),
C = matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3),
phi = 1)
result_bayes$m
prediction_bayes_lm <- exp(result_bayes$m[1] +
result_bayes$m[2] * log(data$x) +
result_bayes$m[3] * data$x)
bayes_lm_plot <- function(sample_size, formula, data, m, C, phi) {
data_sample <- data[1:sample_size,]
result_bayes <- bayes_lm(formula = formula, data = data_sample,m = m,C = C,phi = phi)
prediction_bayes_lm <- exp(result_bayes$m[1] +
result_bayes$m[2] * log(data$x) +
result_bayes$m[3] * data$x)
plot_data <- tibble(t = data$x[-(1:sample_size)], p_my = prediction_bayes_lm[-(1:sample_size)])
ggplot(data = data, aes(x = x)) +
geom_line(data = data, aes(x = x, y = y), color = "black") +
geom_line(data = plot_data, aes(x = t, y = p_my), color = "red")
}
data <- tibble(x = seq_along(y),
y = y)
woods_function <- log(y) ~ 1 + log(x) + x
m <- c(2,0.1,-0.002)
C <- matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3)
phi <- 1
bayes_lm_plot(sample_size = 20, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 50, formula = woods_function, data = data, m = m,C = C,phi = phi)
bayes_lm_plot(sample_size = 100, formula = woods_function, data = data, m = m,C = C,phi = phi)
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(language = "en")
Sys.setlocale("LC_ALL", "English")
library(reshape2)
library(tidyquant)
library(tidyverse)
library(forecast)
library(microbenchmark)
library(aTSA)
library(gridExtra)
library(lubridate)
source("DF_distribution.R") # simulate Dickey Fuller distribution
source("discount.R") # discount prices, bruges i GSADF
source("p_val_fun.R") # calculate p values, bruges i GSADF
source("GSADF.R") # Implementation of GSADF
source("combined_count.R") # count number of intervals the days are in, bruges i plot_GSADF
source("plot_GSADF.R") # plot the result
source("DF_distribution.R") # simulate Dickey Fuller distribution
source("DF_distribution.R") # simulate Dickey Fuller distribution
print(abc)
test_print <- function(abc) {
p <- "abc"
print(p)
}
test_print(et)
source("plot_GSADF.R") # plot the result
