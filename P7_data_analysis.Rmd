---
title: "P7_Data_analysis"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
Sys.setenv(language="en")

library(tidyquant)
library(tidyverse)
library(zoo)
library(gridExtra)
library(tseries)
library(forecast)
library(styler)
```

```{r Plots af rådata}

Pandora_data <- tq_get("PNDORA.CO", get = "stock.prices", from = "2010-01-01", to = "2020-09-08")
ggplot(Pandora_data, aes(x = date, y = adjusted)) +
  geom_line()

Bitcoin_data <- tq_get("BTC-USD", get = "stock.prices", from = "2010-01-01", to = "2020-09-08")

ggplot(Bitcoin_data, aes(x = date, y = adjusted)) +
  geom_line()

DAX_data <- tq_get("^GDAXI", get = "stock.prices", from = "2010-01-01", to = "2020-09-08")
ggplot(DAX_data, aes(x = date, y = adjusted)) +
  geom_line()
```

```{r MA 200 BTC}
#tjek for NA
NA_BTC <- which(is.na(Bitcoin_data$adjusted) == TRUE)
BTC_Close <- Bitcoin_data$adjusted[-c(NA_BTC)]

MA200_BTC <- c(rep(0,200),rollmean(BTC_Close,200))

#Date_MA <- Bitcoin_data$date[-c(1:200)]
#MA200_close_BTC <- data.frame(MA200_BTC,Date_MA)

ggplot(Bitcoin_data, aes(x = date)) +
  geom_line(aes(y=MA200_BTC), colour = "red")+
  geom_line(aes(y=adjusted), colour = "blue")
```

```{r Fucktion til MA}

Call_MA <- function(Stock,y,k){
  
  x <- tq_get(Stock, get = "stock.prices", from = "0000-01-01")
  
  Data <- x[,c(2,8)]
  
  Data_nona <- na.omit(Data)
  
  MA <- c(rollmean(Data_nona$adjusted,y))

  ggplot(tail(Data_nona,n=k), aes(x = date)) +
  geom_line(aes(y=tail(MA,n=k)), colour = "red")+
  geom_line(aes(y=adjusted), colour = "blue")
}

Call_MA("^NDX",200,7000)

#data <- btc %>% filter(!is.na(adjusted)) %>%
  #mutate(logr = c(NA, diff(log(adjusted)))) %>% 
  #select(date, logr) %>% na.omit()

#ggplot(data) +
  #geom_line(aes(x = date, y = logr))


```

```{r TSLA Og VW plot}
TSLA_data <- tq_get("TSLA", get = "stock.prices", from = "2019-01-01")

plot_TSLA <- ggplot(TSLA_data, aes(x = date, y = adjusted)) +
  geom_line() + ggtitle("TSLA")

VOW_data <- tq_get("VOW.DE", get = "stock.prices", from = "2019-01-01")

plot_VOW <- ggplot(VOW_data, aes(x = date, y = adjusted)) +
  geom_line() + ggtitle("VOW.DE")

grid.arrange(plot_TSLA, plot_VOW, ncol =2 )

```

```{r Generering af df kvantiler}
DF_distri <- function(T_val = 100, seed = 12345, sd_rv = 1, y_0 = 1, n_monte = 10) {
  set.seed(seed)
  t_vector <- c()
  list_t_greater_0 <- list()
  k <- 1
  
  for (j in 1:n_monte) {
  y <- c()
  y[1] <- y_0
  y_fin <- c()
    
  for (i in 2:(T_val+T_val/2)) {
    eps <- rnorm(1, mean = 0, sd = sd_rv)
    y[i] <- y[i-1] + eps
    y_fin <- y[((T_val/2)+1):(T_val+T_val/2)]
  }
  data <- tibble()
  data <- tibble(t = 1:T_val,
                 y = y_fin)
  model <- list()
  model <- lm(diff(y) ~ lag(y)[2:T_val], data = data)
  
  if (coef(model)[2] > 0) {
    list_t_greater_0[[k]] <- list(y = data$y,
                                model = summary(model),
                                t_val = summary(model)$coefficients[2,3])
    k <- k + 1
  }
  
  t_vector[j] <- summary(model)$coefficients[2,3]
  }
  
  t_90 <- sort(t_vector, decreasing = T)[n_monte * 0.90]
  t_95 <- sort(t_vector, decreasing = T)[n_monte * 0.95]
  t_99 <- sort(t_vector, decreasing = T)[n_monte * 0.99]
  
  list_return <- list()
  list_return <- list(t_vector = t_vector,
                      quantile_90 = t_90,
                      quantile_95 = t_95,
                      quantile_99 = t_99,
                      list_0 = list_t_greater_0
                      )
  return(list_return)
}

df_distr_test <- DF_distri(T_val = 50, n_monte = 10000)
summary(df_distr_test)
ggplot(data.frame(y = df_distr_test$t_vector), aes(y)) + geom_density()
df_distr_test$quantile_90
df_distr_test$quantile_95
df_distr_test$quantile_99
```


```{r udregning af t værdi}
eps_test <- rnorm(100,0,1)
  y <- c(1:100)
  y[1] <- 0
for (i in 2:100) {
  y[i] <- y[i-1] + eps_test[i]
}
y_ts <- ts(y)


d.y <- diff(y_ts)
plot(d.y)

m.d.y <- mean(d.y)
s.d.y <- sd(d.y)

```

```{r Funktion der måske ikke skal bruges}

sig.df <- function(timeseries,hyp_0 = 0){
  
  estimate <- lm(diff(timeseries) ~ lag(timeseries)[2:length(timeseries)])
  estimate_fin <- as.numeric(estimate$coefficients[2])
  
  print(estimate_fin)
  
  t.val <- (estimate_fin-hyp_0)/(sd(timeseries)/sqrt(length(timeseries)))
  
  print(t.val)
  
  if(t.val > df_distr_test$quantile_90){
    cat("Ikke significant på 90 \n")
  }
    else{
      cat("Signifikant på 90 \n")
    }

  if(t.val > df_distr_test$quantile_95){
    cat("Ikke significant på 95 \n")
  }
    else{
      cat("Signifikant på 95 \n")
    }
  if(t.val > df_distr_test$quantile_99){
    cat("Ikke significant på 99 \n")
  }
    else{
      cat("Signifikant på 99 \n")
    }
  
  return(t.val)
}

```

```{r tvalue function}

tval <- function(timeseries){
  estimate <- lm(diff(timeseries) ~ lag(timeseries)[2:length(timeseries)])
  summary(estimate)$coefficients[2,3]
}

tval(y)


```

```{r Udregning af p-værdi}
listsort <- sort(df_distr_test$t_vector, decreasing = T)
  
p.value <- function(list, y,n_monte = 10000){
  listsort <- sort(list, decreasing = T)
  1-which(abs(listsort-y)==min(abs(listsort-y)))/n_monte
}

p.value(list = df_distr_test$t_vector ,-2.63)
```

```{r}

Bitcoin_data <- tq_get(x = "btc-usd", get = "stock.prices", from = "0000-01-01")
btc <- na.omit(Bitcoin_data$close)

test_adf <- adf.test(Bitcoin_data$close %>% na.omit(), k = 0, alternative = "stationary")

plot.ts(Bitcoin_data$close)


GSADF_fun <- function(x, min_window, step_length) {
  n_row_x <- length(x)
  # max_i <- floor(n_row_x/step_length) - min_window
  max_i <- floor((n_row_x - min_window) / step_length)
  
  adf_list <- list()
  result <- tibble()
  k_ind <- 1
  for (i in 0:max_i) {
    adf_list[[k_ind]] <- suppressWarnings(adf.test(x = x[(step_length*(i)):((step_length*(i)) + min_window)],
                              alternative = "stationary",
                              k = 0))
    result[k_ind, "t_value"] <- adf_list[[k_ind]][["statistic"]][["Dickey-Fuller"]]
    result[k_ind, "start_day"] <- step_length*(i)
    result[k_ind, "end_day"] <- ((step_length*(i)) + min_window)
    result[k_ind, "interval_length"] <- min_window
    k_ind <- k_ind + 1
  }
  result
}

GSADF_fun_result <- GSADF_fun(x = btc, min_window = 30, step_length = 5)

plot.ts(rev(Bitcoin_data$close))
```
